// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: alerts.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acknowledgeAlert = `-- name: AcknowledgeAlert :one
UPDATE alerts 
SET 
    acknowledged = TRUE,
    acknowledged_by = $2,
    acknowledged_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, severity, title, message, source, timestamp, acknowledged, acknowledged_by, acknowledged_at, resolved, resolved_by, resolved_at, resolved_notes, metadata, created_at, updated_at
`

type AcknowledgeAlertParams struct {
	ID             pgtype.UUID `db:"id" json:"id"`
	AcknowledgedBy pgtype.Text `db:"acknowledged_by" json:"acknowledged_by"`
}

func (q *Queries) AcknowledgeAlert(ctx context.Context, arg AcknowledgeAlertParams) (Alert, error) {
	row := q.db.QueryRow(ctx, acknowledgeAlert, arg.ID, arg.AcknowledgedBy)
	var i Alert
	err := row.Scan(
		&i.ID,
		&i.Severity,
		&i.Title,
		&i.Message,
		&i.Source,
		&i.Timestamp,
		&i.Acknowledged,
		&i.AcknowledgedBy,
		&i.AcknowledgedAt,
		&i.Resolved,
		&i.ResolvedBy,
		&i.ResolvedAt,
		&i.ResolvedNotes,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countAlerts = `-- name: CountAlerts :one
SELECT COUNT(*) FROM alerts
WHERE 
    ($1::text IS NULL OR severity = $1) AND
    ($2::boolean IS NULL OR acknowledged = $2) AND
    ($3::boolean IS NULL OR resolved = $3) AND
    ($4::text IS NULL OR source = $4) AND
    ($5::timestamptz IS NULL OR timestamp >= $5) AND
    ($6::timestamptz IS NULL OR timestamp <= $6)
`

type CountAlertsParams struct {
	Column1 string             `db:"column_1" json:"column_1"`
	Column2 bool               `db:"column_2" json:"column_2"`
	Column3 bool               `db:"column_3" json:"column_3"`
	Column4 string             `db:"column_4" json:"column_4"`
	Column5 pgtype.Timestamptz `db:"column_5" json:"column_5"`
	Column6 pgtype.Timestamptz `db:"column_6" json:"column_6"`
}

func (q *Queries) CountAlerts(ctx context.Context, arg CountAlertsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAlerts,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAlert = `-- name: CreateAlert :one
INSERT INTO alerts (
    severity,
    title,
    message,
    source,
    timestamp,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, severity, title, message, source, timestamp, acknowledged, acknowledged_by, acknowledged_at, resolved, resolved_by, resolved_at, resolved_notes, metadata, created_at, updated_at
`

type CreateAlertParams struct {
	Severity  string             `db:"severity" json:"severity"`
	Title     string             `db:"title" json:"title"`
	Message   string             `db:"message" json:"message"`
	Source    string             `db:"source" json:"source"`
	Timestamp pgtype.Timestamptz `db:"timestamp" json:"timestamp"`
	Metadata  []byte             `db:"metadata" json:"metadata"`
}

func (q *Queries) CreateAlert(ctx context.Context, arg CreateAlertParams) (Alert, error) {
	row := q.db.QueryRow(ctx, createAlert,
		arg.Severity,
		arg.Title,
		arg.Message,
		arg.Source,
		arg.Timestamp,
		arg.Metadata,
	)
	var i Alert
	err := row.Scan(
		&i.ID,
		&i.Severity,
		&i.Title,
		&i.Message,
		&i.Source,
		&i.Timestamp,
		&i.Acknowledged,
		&i.AcknowledgedBy,
		&i.AcknowledgedAt,
		&i.Resolved,
		&i.ResolvedBy,
		&i.ResolvedAt,
		&i.ResolvedNotes,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOldResolvedAlerts = `-- name: DeleteOldResolvedAlerts :exec
DELETE FROM alerts 
WHERE resolved = TRUE 
AND resolved_at < $1
`

func (q *Queries) DeleteOldResolvedAlerts(ctx context.Context, resolvedAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteOldResolvedAlerts, resolvedAt)
	return err
}

const getAlert = `-- name: GetAlert :one
SELECT id, severity, title, message, source, timestamp, acknowledged, acknowledged_by, acknowledged_at, resolved, resolved_by, resolved_at, resolved_notes, metadata, created_at, updated_at FROM alerts WHERE id = $1
`

func (q *Queries) GetAlert(ctx context.Context, id pgtype.UUID) (Alert, error) {
	row := q.db.QueryRow(ctx, getAlert, id)
	var i Alert
	err := row.Scan(
		&i.ID,
		&i.Severity,
		&i.Title,
		&i.Message,
		&i.Source,
		&i.Timestamp,
		&i.Acknowledged,
		&i.AcknowledgedBy,
		&i.AcknowledgedAt,
		&i.Resolved,
		&i.ResolvedBy,
		&i.ResolvedAt,
		&i.ResolvedNotes,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAlertStatistics = `-- name: GetAlertStatistics :one
SELECT 
    COUNT(*) as total_alerts,
    COUNT(*) FILTER (WHERE severity = 'critical') as critical_count,
    COUNT(*) FILTER (WHERE severity = 'warning') as warning_count,
    COUNT(*) FILTER (WHERE severity = 'info') as info_count,
    COUNT(*) FILTER (WHERE acknowledged = TRUE) as acknowledged_count,
    COUNT(*) FILTER (WHERE resolved = TRUE) as resolved_count,
    COUNT(*) FILTER (WHERE resolved = FALSE) as unresolved_count
FROM alerts
WHERE 
    ($1::timestamptz IS NULL OR timestamp >= $1) AND
    ($2::timestamptz IS NULL OR timestamp <= $2)
`

type GetAlertStatisticsParams struct {
	Column1 pgtype.Timestamptz `db:"column_1" json:"column_1"`
	Column2 pgtype.Timestamptz `db:"column_2" json:"column_2"`
}

type GetAlertStatisticsRow struct {
	TotalAlerts       int64 `db:"total_alerts" json:"total_alerts"`
	CriticalCount     int64 `db:"critical_count" json:"critical_count"`
	WarningCount      int64 `db:"warning_count" json:"warning_count"`
	InfoCount         int64 `db:"info_count" json:"info_count"`
	AcknowledgedCount int64 `db:"acknowledged_count" json:"acknowledged_count"`
	ResolvedCount     int64 `db:"resolved_count" json:"resolved_count"`
	UnresolvedCount   int64 `db:"unresolved_count" json:"unresolved_count"`
}

func (q *Queries) GetAlertStatistics(ctx context.Context, arg GetAlertStatisticsParams) (GetAlertStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getAlertStatistics, arg.Column1, arg.Column2)
	var i GetAlertStatisticsRow
	err := row.Scan(
		&i.TotalAlerts,
		&i.CriticalCount,
		&i.WarningCount,
		&i.InfoCount,
		&i.AcknowledgedCount,
		&i.ResolvedCount,
		&i.UnresolvedCount,
	)
	return i, err
}

const getAlertsBySource = `-- name: GetAlertsBySource :many
SELECT id, severity, title, message, source, timestamp, acknowledged, acknowledged_by, acknowledged_at, resolved, resolved_by, resolved_at, resolved_notes, metadata, created_at, updated_at FROM alerts 
WHERE source = $1 AND resolved = FALSE
ORDER BY timestamp DESC
LIMIT $2
`

type GetAlertsBySourceParams struct {
	Source string `db:"source" json:"source"`
	Limit  int32  `db:"limit" json:"limit"`
}

func (q *Queries) GetAlertsBySource(ctx context.Context, arg GetAlertsBySourceParams) ([]Alert, error) {
	rows, err := q.db.Query(ctx, getAlertsBySource, arg.Source, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Alert{}
	for rows.Next() {
		var i Alert
		if err := rows.Scan(
			&i.ID,
			&i.Severity,
			&i.Title,
			&i.Message,
			&i.Source,
			&i.Timestamp,
			&i.Acknowledged,
			&i.AcknowledgedBy,
			&i.AcknowledgedAt,
			&i.Resolved,
			&i.ResolvedBy,
			&i.ResolvedAt,
			&i.ResolvedNotes,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnresolvedAlertsCount = `-- name: GetUnresolvedAlertsCount :one
SELECT COUNT(*) FROM alerts WHERE resolved = FALSE
`

func (q *Queries) GetUnresolvedAlertsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getUnresolvedAlertsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listAlerts = `-- name: ListAlerts :many
SELECT id, severity, title, message, source, timestamp, acknowledged, acknowledged_by, acknowledged_at, resolved, resolved_by, resolved_at, resolved_notes, metadata, created_at, updated_at FROM alerts
WHERE 
    ($1::text IS NULL OR severity = $1) AND
    ($2::boolean IS NULL OR acknowledged = $2) AND
    ($3::boolean IS NULL OR resolved = $3) AND
    ($4::text IS NULL OR source = $4) AND
    ($5::timestamptz IS NULL OR timestamp >= $5) AND
    ($6::timestamptz IS NULL OR timestamp <= $6)
ORDER BY timestamp DESC
LIMIT $7 OFFSET $8
`

type ListAlertsParams struct {
	Column1 string             `db:"column_1" json:"column_1"`
	Column2 bool               `db:"column_2" json:"column_2"`
	Column3 bool               `db:"column_3" json:"column_3"`
	Column4 string             `db:"column_4" json:"column_4"`
	Column5 pgtype.Timestamptz `db:"column_5" json:"column_5"`
	Column6 pgtype.Timestamptz `db:"column_6" json:"column_6"`
	Limit   int32              `db:"limit" json:"limit"`
	Offset  int32              `db:"offset" json:"offset"`
}

func (q *Queries) ListAlerts(ctx context.Context, arg ListAlertsParams) ([]Alert, error) {
	rows, err := q.db.Query(ctx, listAlerts,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Alert{}
	for rows.Next() {
		var i Alert
		if err := rows.Scan(
			&i.ID,
			&i.Severity,
			&i.Title,
			&i.Message,
			&i.Source,
			&i.Timestamp,
			&i.Acknowledged,
			&i.AcknowledgedBy,
			&i.AcknowledgedAt,
			&i.Resolved,
			&i.ResolvedBy,
			&i.ResolvedAt,
			&i.ResolvedNotes,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveAlert = `-- name: ResolveAlert :one
UPDATE alerts 
SET 
    resolved = TRUE,
    resolved_by = $2,
    resolved_at = NOW(),
    resolved_notes = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, severity, title, message, source, timestamp, acknowledged, acknowledged_by, acknowledged_at, resolved, resolved_by, resolved_at, resolved_notes, metadata, created_at, updated_at
`

type ResolveAlertParams struct {
	ID            pgtype.UUID `db:"id" json:"id"`
	ResolvedBy    pgtype.Text `db:"resolved_by" json:"resolved_by"`
	ResolvedNotes pgtype.Text `db:"resolved_notes" json:"resolved_notes"`
}

func (q *Queries) ResolveAlert(ctx context.Context, arg ResolveAlertParams) (Alert, error) {
	row := q.db.QueryRow(ctx, resolveAlert, arg.ID, arg.ResolvedBy, arg.ResolvedNotes)
	var i Alert
	err := row.Scan(
		&i.ID,
		&i.Severity,
		&i.Title,
		&i.Message,
		&i.Source,
		&i.Timestamp,
		&i.Acknowledged,
		&i.AcknowledgedBy,
		&i.AcknowledgedAt,
		&i.Resolved,
		&i.ResolvedBy,
		&i.ResolvedAt,
		&i.ResolvedNotes,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const searchAlerts = `-- name: SearchAlerts :many
SELECT id, severity, title, message, source, timestamp, acknowledged, acknowledged_by, acknowledged_at, resolved, resolved_by, resolved_at, resolved_notes, metadata, created_at, updated_at FROM alerts
WHERE 
    ($1::text IS NULL OR (
        title ILIKE '%' || $1 || '%' OR 
        message ILIKE '%' || $1 || '%' OR
        source ILIKE '%' || $1 || '%'
    )) AND
    ($2::text IS NULL OR severity = $2) AND
    ($3::boolean IS NULL OR acknowledged = $3) AND
    ($4::boolean IS NULL OR resolved = $4) AND
    ($5::timestamptz IS NULL OR timestamp >= $5) AND
    ($6::timestamptz IS NULL OR timestamp <= $6)
ORDER BY 
    CASE WHEN $7 = 'timestamp' AND $8 = true THEN timestamp END DESC,
    CASE WHEN $7 = 'timestamp' AND $8 = false THEN timestamp END ASC,
    CASE WHEN $7 = 'severity' AND $8 = true THEN 
        CASE severity 
            WHEN 'critical' THEN 1 
            WHEN 'warning' THEN 2 
            WHEN 'info' THEN 3 
        END 
    END DESC,
    CASE WHEN $7 = 'severity' AND $8 = false THEN 
        CASE severity 
            WHEN 'info' THEN 1 
            WHEN 'warning' THEN 2 
            WHEN 'critical' THEN 3 
        END 
    END DESC,
    timestamp DESC
LIMIT $9 OFFSET $10
`

type SearchAlertsParams struct {
	Column1 string             `db:"column_1" json:"column_1"`
	Column2 string             `db:"column_2" json:"column_2"`
	Column3 bool               `db:"column_3" json:"column_3"`
	Column4 bool               `db:"column_4" json:"column_4"`
	Column5 pgtype.Timestamptz `db:"column_5" json:"column_5"`
	Column6 pgtype.Timestamptz `db:"column_6" json:"column_6"`
	Column7 interface{}        `db:"column_7" json:"column_7"`
	Column8 interface{}        `db:"column_8" json:"column_8"`
	Limit   int32              `db:"limit" json:"limit"`
	Offset  int32              `db:"offset" json:"offset"`
}

func (q *Queries) SearchAlerts(ctx context.Context, arg SearchAlertsParams) ([]Alert, error) {
	rows, err := q.db.Query(ctx, searchAlerts,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Alert{}
	for rows.Next() {
		var i Alert
		if err := rows.Scan(
			&i.ID,
			&i.Severity,
			&i.Title,
			&i.Message,
			&i.Source,
			&i.Timestamp,
			&i.Acknowledged,
			&i.AcknowledgedBy,
			&i.AcknowledgedAt,
			&i.Resolved,
			&i.ResolvedBy,
			&i.ResolvedAt,
			&i.ResolvedNotes,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
